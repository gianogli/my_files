diff --git a/userland/examples_zc/zbalance_ipc.c b/userland/examples_zc/zbalance_ipc.c
index 7dd7ad6..c82173e 100644
--- a/userland/examples_zc/zbalance_ipc.c
+++ b/userland/examples_zc/zbalance_ipc.c
@@ -36,6 +36,12 @@
 #include <sched.h>
 #include <stdio.h>

+#define ENABLE_BPF
+#ifdef ENABLE_BPF
+#include <pcap/pcap.h>
+#include <pcap/bpf.h>
+#endif
+
 #include "pfring.h"
 #include "pfring_zc.h"
 #include "pfring_mod_sysdig.h"
@@ -59,6 +65,9 @@
 #define CACHE_LINE_LEN         64
 #define MAX_NUM_APP	       32
 #define IN_POOL_SIZE          256
+#ifdef ENABLE_BPF
+#define MAX_NUM_BPF            16
+#endif

 pfring_zc_cluster *zc;
 pfring_zc_worker *zw;
@@ -98,6 +108,11 @@ u_int32_t n2disk_threads; 
 char *vlan_filter = NULL;
 bitmap64_t(allowed_vlans, 1024);
 
+#ifdef ENABLE_BPF
+  char *custom_bpf[MAX_NUM_BPF];
+  struct bpf_program bpf_code[MAX_NUM_BPF];
+#endif
+
 /* ******************************** */

 #ifdef HAVE_PF_RING_FT
@@ -589,7 +603,14 @@ void printHelp(void) {
          "                 3 - Fan-out (1st) + Round-Robin (2nd, 3rd, ..)\n"
          "                 4 - GTP hash (Inner IP/Port or Seq-Num or Outer IP/Port)\n"
          "                 5 - GRE hash (Inner or Outer IP)\n"
-         "                 6 - Interface X to queue X\n");
+         "                 6 - Interface X to queue X\n"
+#ifdef ENABLE_BPF
+         "                 7 - BPF mode: custom balancer by using BPF filters\n");
+  printf("-F <BPF filters> In case of '-m 7' you must configure (<num inst> - 1) BPF filters using a\n"
+         "                 comma-separated list. The last instance will have all the packets that aren't\n"
+         "                 been matched by the previous configured BPF filters\n"
+#endif
+         );
   printf("-r <queue>:<dev> Replace egress queue <queue> with device <dev> (multiple -r can be specified)\n");
   printf("-S <core id>     Enable Time Pulse thread and bind it to a core\n");
   printf("-R <nsec>        Time resolution (nsec) when using Time Pulse thread\n"
@@ -724,6 +745,19 @@ int64_t ip_distribution_func(pfring_zc_pkt_buff *pkt_handle, pfring_zc_queue *in_queue, void *user) {
   return pfring_zc_builtin_ip_hash(pkt_handle, in_queue) % num_out_queues;
 }

+#ifdef ENABLE_BPF
+/* *************************************** */
+
+int64_t ip_bpf_distribution_func(pfring_zc_pkt_buff *pkt_handle, pfring_zc_queue *in_queue, void *user) {
+  long num_out_queues = (long) user;
+  u_int32_t i;
+
+  for (i = 0; i < (num_out_queues - 1); i++) {
+    if (unlikely(pfring_bpf_filter((bpf_code[i]).bf_insns, pfring_zc_pkt_buff_data(pkt_handle, in_queue), pkt_handle->len, pkt_handle->len))) return i;
+  }
+  return i;
+}
+#endif
 /* *************************************** */

 int64_t gtp_distribution_func(pfring_zc_pkt_buff *pkt_handle, pfring_zc_queue *in_queue, void *user) {
@@ -918,6 +952,9 @@ int main(int argc, char* argv[]) {
 #ifdef HAVE_ZMQ 
     "A:E:Z"
 #endif
+#ifdef ENABLE_BPF
+    "F:"
+#endif
   ;
 #ifdef HAVE_PF_RING_FT
   char *ft_rules_conf = NULL;
@@ -929,6 +966,11 @@ int main(int argc, char* argv[]) {
   pfring_zc_idle_callback idle_func = NULL;
   pfring_zc_distribution_func distr_func = NULL;
   pfring_zc_filtering_func filter_func = NULL;
+ 
+#ifdef ENABLE_BPF
+  char *filters = NULL, *bpf, *bpf_pos = NULL;
+  u_int32_t num_bpfs = 0;
+#endif

   start_time.tv_sec = 0;

@@ -1048,6 +1090,11 @@ int main(int argc, char* argv[]) {
       time_pulse = 1; /* forcing time-pulse to handle rules expiration */
     break;
 #endif
+#ifdef ENABLE_BPF
+    case 'F':
+      filters = strdup(optarg);
+      break;
+#endif
     case 'v':
       trace_verbosity = 3;    
     break;
@@ -1129,6 +1175,11 @@ int main(int argc, char* argv[]) {
       case 6:
         num_consumer_queues_limit = 64; /* egress mask is 64 bit */
         break;
+#ifdef ENABLE_BPF
+      case 7:
+        num_consumer_queues_limit = MAX_NUM_BPF;
+        break;
+#endif
       default:
         printHelp();
         break;
@@ -1148,6 +1194,29 @@ int main(int argc, char* argv[]) {
     return -1;
   }
 
+#ifdef ENABLE_BPF
+  if ((hash_mode == 7 && (filters == NULL || num_consumer_queues < 2)) || (hash_mode != 7 && filters != NULL)) printHelp();
+
+  if (filters != NULL) {
+    bpf = strtok_r(filters, ",", &bpf_pos);
+    while (bpf != NULL && num_bpfs < MAX_NUM_BPF) {
+      custom_bpf[num_bpfs] = (char *)malloc(strlen(bpf) + 1);
+      strcpy (custom_bpf[num_bpfs], bpf);
+      num_bpfs++;
+      bpf = strtok_r(NULL, ",", &bpf_pos);
+    }
+
+    if (hash_mode == 7 && num_bpfs != (num_consumer_queues -1)) printHelp();
+
+    for (i = 0; i < num_bpfs; i++) {
+      if (pfring_parse_bpf_filter(custom_bpf[i], MAX_CAPLEN, &(bpf_code[i])) != 0) {
+        trace(TRACE_ERROR, "Error detected: the BPF filter #%i is not recognized\n", i +1);
+        return -1;
+      }
+    }
+  }
+#endif
+
   for (i = 0; i < num_devices; i++) {
     if (strcmp(devices[i], "Q") != 0) num_real_devices++;
     else num_in_queues++;
@@ -1405,6 +1474,15 @@ int main(int argc, char* argv[]) {

   trace(TRACE_NORMAL, "Starting balancer with %d consumer queues..\n", num_consumer_queues);

+#ifdef ENABLE_BPF
+  if (filters != NULL) {
+    for (i = 0; i < num_bpfs; i++) {
+        trace(TRACE_NORMAL, "      BPF(Q %i) => %s\n", i, custom_bpf[i]);
+    }
+    trace(TRACE_NORMAL, "      BPF(Q %i) => All the packets that aren't been matched by the previous BPF filters\n", i);
+  }
+#endif
+
   off = 0;

   if (num_in_queues > 0) {
@@ -1432,7 +1516,11 @@ int main(int argc, char* argv[]) {
 
   trace(TRACE_NORMAL, "Running...");
 
+#ifdef ENABLE_BPF
+  if (hash_mode == 0 || ((hash_mode == 1 || hash_mode == 4 || hash_mode == 5 || hash_mode == 6) && num_apps == 1) || hash_mode == 7) { /* balancer */
+#else
   if (hash_mode == 0 || ((hash_mode == 1 || hash_mode == 4 || hash_mode == 5 || hash_mode == 6) && num_apps == 1)) { /* balancer */
+#endif
 
     switch (hash_mode) {
       case 0: distr_func = rr_distribution_func;
@@ -1458,6 +1546,11 @@ int main(int argc, char* argv[]) {
       case 6: 
         distr_func =  direct_distribution_func;
       break;
+#ifdef ENABLE_BPF
+      case 7:
+        distr_func = ip_bpf_distribution_func;
+      break;
+#endif
     }
 
     zw = pfring_zc_run_balancer_v2(
